{"version":3,"file":"db.js","sources":["../node_modules/ulid/dist/browser/index.js","../src/lib/db/db.ts","../src/lib/db/collection.ts"],"sourcesContent":["// These values should NEVER change. The values are precisely for\n// generating ULIDs.\nconst B32_CHARACTERS = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nconst ENCODING_LEN = 32; // from ENCODING.length;\nconst MAX_ULID = \"7ZZZZZZZZZZZZZZZZZZZZZZZZZ\";\nconst MIN_ULID = \"00000000000000000000000000\";\nconst RANDOM_LEN = 16;\nconst TIME_LEN = 10;\nconst TIME_MAX = 281474976710655; // from Math.pow(2, 48) - 1;\nconst ULID_REGEX = /^[0-7][0-9a-hjkmnp-tv-zA-HJKMNP-TV-Z]{25}$/;\nconst UUID_REGEX = /^[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/;\n\nvar ULIDErrorCode;\n(function (ULIDErrorCode) {\n    ULIDErrorCode[\"Base32IncorrectEncoding\"] = \"B32_ENC_INVALID\";\n    ULIDErrorCode[\"DecodeTimeInvalidCharacter\"] = \"DEC_TIME_CHAR\";\n    ULIDErrorCode[\"DecodeTimeValueMalformed\"] = \"DEC_TIME_MALFORMED\";\n    ULIDErrorCode[\"EncodeTimeNegative\"] = \"ENC_TIME_NEG\";\n    ULIDErrorCode[\"EncodeTimeSizeExceeded\"] = \"ENC_TIME_SIZE_EXCEED\";\n    ULIDErrorCode[\"EncodeTimeValueMalformed\"] = \"ENC_TIME_MALFORMED\";\n    ULIDErrorCode[\"PRNGDetectFailure\"] = \"PRNG_DETECT\";\n    ULIDErrorCode[\"ULIDInvalid\"] = \"ULID_INVALID\";\n    ULIDErrorCode[\"Unexpected\"] = \"UNEXPECTED\";\n    ULIDErrorCode[\"UUIDInvalid\"] = \"UUID_INVALID\";\n})(ULIDErrorCode || (ULIDErrorCode = {}));\nclass ULIDError extends Error {\n    constructor(errorCode, message) {\n        super(`${message} (${errorCode})`);\n        this.name = \"ULIDError\";\n        this.code = errorCode;\n    }\n}\n\nfunction randomChar(prng) {\n    // Currently PRNGs generate fractions from 0 to _less than_ 1, so no \"%\" is necessary.\n    // However, just in case a future PRNG can generate 1,\n    // we are applying \"% ENCODING LEN\" to wrap back to the first character\n    const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;\n    return ENCODING.charAt(randomPosition);\n}\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\n\n// Code from https://github.com/devbanana/crockford-base32/blob/develop/src/index.ts\nfunction crockfordEncode(input) {\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    const reversedInput = new Uint8Array(input.slice().reverse());\n    for (const byte of reversedInput) {\n        buffer |= byte << bitsRead;\n        bitsRead += 8;\n        while (bitsRead >= 5) {\n            output.unshift(buffer & 0x1f);\n            buffer >>>= 5;\n            bitsRead -= 5;\n        }\n    }\n    if (bitsRead > 0) {\n        output.unshift(buffer & 0x1f);\n    }\n    return output.map(byte => B32_CHARACTERS.charAt(byte)).join(\"\");\n}\nfunction crockfordDecode(input) {\n    const sanitizedInput = input.toUpperCase().split(\"\").reverse().join(\"\");\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    for (const character of sanitizedInput) {\n        const byte = B32_CHARACTERS.indexOf(character);\n        if (byte === -1) {\n            throw new Error(`Invalid base 32 character found in string: ${character}`);\n        }\n        buffer |= byte << bitsRead;\n        bitsRead += 5;\n        while (bitsRead >= 8) {\n            output.unshift(buffer & 0xff);\n            buffer >>>= 8;\n            bitsRead -= 8;\n        }\n    }\n    if (bitsRead >= 5 || buffer > 0) {\n        output.unshift(buffer & 0xff);\n    }\n    return new Uint8Array(output);\n}\n/**\n * Fix a ULID's Base32 encoding -\n * i and l (case-insensitive) will be treated as 1 and o (case-insensitive) will be treated as 0.\n * hyphens are ignored during decoding.\n * @param id The ULID\n * @returns The cleaned up ULID\n */\nfunction fixULIDBase32(id) {\n    return id.replace(/i/gi, \"1\").replace(/l/gi, \"1\").replace(/o/gi, \"0\").replace(/-/g, \"\");\n}\nfunction incrementBase32(str) {\n    let done = undefined, index = str.length, char, charIndex, output = str;\n    const maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = output[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, \"Incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            output = replaceCharAt(output, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(output, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, \"Failed incrementing string\");\n}\n\n/**\n * Decode time from a ULID\n * @param id The ULID\n * @returns The decoded timestamp\n */\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, \"Malformed ULID\");\n    }\n    const time = id\n        .substr(0, TIME_LEN)\n        .toUpperCase()\n        .split(\"\")\n        .reverse()\n        .reduce((carry, char, index) => {\n        const encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw new ULIDError(ULIDErrorCode.DecodeTimeInvalidCharacter, `Time decode error: Invalid character: ${char}`);\n        }\n        return (carry += encodingIndex * Math.pow(ENCODING_LEN, index));\n    }, 0);\n    if (time > TIME_MAX) {\n        throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, `Malformed ULID: timestamp too large: ${time}`);\n    }\n    return time;\n}\n/**\n * Detect the best PRNG (pseudo-random number generator)\n * @param root The root to check from (global/window)\n * @returns The PRNG function\n */\nfunction detectPRNG(root) {\n    const rootLookup = detectRoot();\n    const globalCrypto = (rootLookup && (rootLookup.crypto || rootLookup.msCrypto)) ||\n        (null);\n    if (typeof globalCrypto?.getRandomValues === \"function\") {\n        return () => {\n            const buffer = new Uint8Array(1);\n            globalCrypto.getRandomValues(buffer);\n            return buffer[0] / 256;\n        };\n    }\n    else if (typeof globalCrypto?.randomBytes === \"function\") {\n        return () => globalCrypto.randomBytes(1).readUInt8() / 256;\n    }\n    else ;\n    throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, \"Failed to find a reliable PRNG\");\n}\nfunction detectRoot() {\n    if (inWebWorker())\n        return self;\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    return null;\n}\nfunction encodeRandom(len, prng) {\n    let str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\n/**\n * Encode the time portion of a ULID\n * @param now The current timestamp\n * @param len Length to generate\n * @returns The encoded time\n */\nfunction encodeTime(now, len = TIME_LEN) {\n    if (isNaN(now)) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now}`);\n    }\n    else if (now > TIME_MAX) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now}`);\n    }\n    else if (now < 0) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now}`);\n    }\n    else if (Number.isInteger(now) === false) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now}`);\n    }\n    let mod, str = \"\";\n    for (let currentLen = len; currentLen > 0; currentLen--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction inWebWorker() {\n    // @ts-ignore\n    return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\n/**\n * Check if a ULID is valid\n * @param id The ULID to test\n * @returns True if valid, false otherwise\n * @example\n *   isValid(\"01HNZX8JGFACFA36RBXDHEQN6E\"); // true\n *   isValid(\"\"); // false\n */\nfunction isValid(id) {\n    return (typeof id === \"string\" &&\n        id.length === TIME_LEN + RANDOM_LEN &&\n        id\n            .toUpperCase()\n            .split(\"\")\n            .every(char => ENCODING.indexOf(char) !== -1));\n}\n/**\n * Create a ULID factory to generate monotonically-increasing\n *  ULIDs\n * @param prng The PRNG to use\n * @returns A ulid factory\n * @example\n *  const ulid = monotonicFactory();\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction monotonicFactory(prng) {\n    const currentPRNG = prng || detectPRNG();\n    let lastTime = 0, lastRandom;\n    return function _ulid(seedTime) {\n        const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;\n        if (seed <= lastTime) {\n            const incrementedRandom = (lastRandom = incrementBase32(lastRandom));\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seed;\n        const newRandom = (lastRandom = encodeRandom(RANDOM_LEN, currentPRNG));\n        return encodeTime(seed, TIME_LEN) + newRandom;\n    };\n}\n/**\n * Generate a ULID\n * @param seedTime Optional time seed\n * @param prng Optional PRNG function\n * @returns A ULID string\n * @example\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction ulid(seedTime, prng) {\n    const currentPRNG = prng || detectPRNG();\n    const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;\n    return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);\n}\n\n/**\n * Convert a ULID to a UUID\n * @param ulid The ULID to convert\n * @returns A UUID string\n */\nfunction ulidToUUID(ulid) {\n    const isValid = ULID_REGEX.test(ulid);\n    if (!isValid) {\n        throw new ULIDError(ULIDErrorCode.ULIDInvalid, `Invalid ULID: ${ulid}`);\n    }\n    const uint8Array = crockfordDecode(ulid);\n    let uuid = Array.from(uint8Array)\n        .map(byte => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n    uuid =\n        uuid.substring(0, 8) +\n            \"-\" +\n            uuid.substring(8, 12) +\n            \"-\" +\n            uuid.substring(12, 16) +\n            \"-\" +\n            uuid.substring(16, 20) +\n            \"-\" +\n            uuid.substring(20);\n    return uuid.toUpperCase();\n}\n/**\n * Convert a UUID to a ULID\n * @param uuid The UUID to convert\n * @returns A ULID string\n */\nfunction uuidToULID(uuid) {\n    const isValid = UUID_REGEX.test(uuid);\n    if (!isValid) {\n        throw new ULIDError(ULIDErrorCode.UUIDInvalid, `Invalid UUID: ${uuid}`);\n    }\n    const bytes = uuid.replace(/-/g, \"\").match(/.{1,2}/g);\n    if (!bytes) {\n        throw new ULIDError(ULIDErrorCode.Unexpected, `Failed parsing UUID bytes: ${uuid}`);\n    }\n    const uint8Array = new Uint8Array(bytes.map(byte => parseInt(byte, 16)));\n    return crockfordEncode(uint8Array);\n}\n\nexport { MAX_ULID, MIN_ULID, TIME_LEN, TIME_MAX, ULIDError, ULIDErrorCode, decodeTime, encodeTime, fixULIDBase32, incrementBase32, isValid, monotonicFactory, ulid, ulidToUUID, uuidToULID };\n",null,null],"names":[],"mappings":"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","x_google_ignoreList":[0]}